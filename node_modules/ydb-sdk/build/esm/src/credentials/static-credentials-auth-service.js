"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticCredentialsAuthService = void 0;
const ydb_sdk_proto_1 = require("ydb-sdk-proto");
var AuthServiceResult = ydb_sdk_proto_1.Ydb.Auth.LoginResult;
const utils_1 = require("../utils");
const retries_obsoleted_1 = require("../retries_obsoleted");
const luxon_1 = require("luxon");
const process_ydb_operation_result_1 = require("../utils/process-ydb-operation-result");
const add_credentials_to_metadata_1 = require("./add-credentials-to-metadata");
const get_default_logger_1 = require("../logger/get-default-logger");
class StaticCredentialsGrpcService extends utils_1.GrpcService {
    logger;
    constructor(endpoint, sslCredentials, logger = (0, get_default_logger_1.getDefaultLogger)()) {
        super(endpoint, 'Ydb.Auth.V1.AuthService', ydb_sdk_proto_1.Ydb.Auth.V1.AuthService, sslCredentials);
        this.logger = logger;
    }
    login(request) {
        return this.api.login(request);
    }
    destroy() {
        this.api.end();
    }
}
__decorate([
    (0, retries_obsoleted_1.retryable)()
], StaticCredentialsGrpcService.prototype, "login", null);
class StaticCredentialsAuthService {
    tokenRequestTimeout = 10 * 1000;
    tokenExpirationTimeout = 6 * 60 * 60 * 1000;
    tokenTimestamp;
    token = '';
    tokenUpdatePromise = null;
    user;
    password;
    endpoint;
    sslCredentials;
    logger;
    constructor(user, password, endpoint, loggerOrOptions, options) {
        this.tokenTimestamp = null;
        this.user = user;
        this.password = password;
        this.endpoint = endpoint;
        this.sslCredentials = options?.sslCredentials;
        if (typeof loggerOrOptions === 'object' && loggerOrOptions !== null && 'error' in loggerOrOptions) {
            this.logger = loggerOrOptions;
        }
        else {
            options = loggerOrOptions;
            this.logger = (0, get_default_logger_1.getDefaultLogger)();
        }
        if (options?.tokenRequestTimeout)
            this.tokenRequestTimeout = options.tokenRequestTimeout;
        if (options?.tokenExpirationTimeout)
            this.tokenExpirationTimeout = options.tokenExpirationTimeout;
    }
    get expired() {
        return !this.tokenTimestamp || (luxon_1.DateTime.utc().diff(this.tokenTimestamp).valueOf() > this.tokenExpirationTimeout);
    }
    async sendTokenRequest() {
        let runtimeAuthService = new StaticCredentialsGrpcService(this.endpoint, this.sslCredentials, this.logger);
        const tokenPromise = runtimeAuthService.login({
            user: this.user,
            password: this.password,
        });
        const response = await (0, utils_1.withTimeout)(tokenPromise, this.tokenRequestTimeout);
        const result = AuthServiceResult.decode((0, process_ydb_operation_result_1.getOperationPayload)(response));
        runtimeAuthService.destroy();
        return result;
    }
    async updateToken() {
        const { token } = await this.sendTokenRequest();
        if (token) {
            this.token = token;
            this.tokenTimestamp = luxon_1.DateTime.utc();
        }
        else {
            throw new Error('Received empty token from static credentials!');
        }
    }
    async getAuthMetadata() {
        if (this.expired || this.tokenUpdatePromise) {
            if (!this.tokenUpdatePromise) {
                this.tokenUpdatePromise = this.updateToken();
            }
            await this.tokenUpdatePromise;
            this.tokenUpdatePromise = null;
        }
        return (0, add_credentials_to_metadata_1.addCredentialsToMetadata)(this.token);
    }
}
exports.StaticCredentialsAuthService = StaticCredentialsAuthService;
