import { idSymbol, cancelListenersSymbol, errSymbol } from './symbols';
export type CtxIdGenerator = () => string;
/**
 * Sets the Context.id generation rule for new contexts. It is desirable to call this funtion at the very beginning of
 * the application before the contexts are used.
 */
export declare function setContextIdGenerator(_idGenerator?: CtxIdGenerator): void;
interface IContextOpts {
    /**
     * Id for new Context from layer above.
     */
    id?: string;
    /**
     * true - make cancellable context. false - cancel cancellable context.
     * undefined - if parent context is cancelable, then child context is also cancellable and vice versa.
     */
    cancel?: boolean;
    /**
     * cancel context after done.
     */
    done?: boolean;
    /**
     * cancel context after timeout.
     */
    timeout?: number;
    /**
     * Force creation of child context, even if there is no sufficient need.
     */
    force?: boolean;
}
export type CtxDone = () => void;
export type CtxDispose = () => void;
export type CtxUnsubcribe = () => void;
export type CtxCancel = (cuase?: Error) => void;
interface IContextCreateResult {
    ctx: Context;
    cancel?: CtxCancel;
    done?: CtxDone;
    dispose?: CtxDispose;
}
type OnCancelListener = (cause: Error) => void;
interface IContextWrapLambda<T> {
    (ctx: Context, cancel?: CtxCancel, done?: CtxDone): Promise<T>;
}
/**
 * TypeScript Context implementation inspired by golang context (https://pkg.go.dev/context).
 *
 * Supports cancel, timeout, value, done, cancel cancel-chain behaviours.
 */
export declare class Context {
    [idSymbol]: string;
    [cancelListenersSymbol]?: OnCancelListener[];
    [errSymbol]?: Error;
    /**
     * Similar to value in go context passes arbitrary values through a hierarchy of contexts.
     */
    [key: symbol]: any;
    private constructor();
    /**
     * Unique id of Context Useful for tracing.
     */
    get id(): string;
    /**
     * That is the cause that was passed to cancel.
     *
     * If defined, the context is cancelled.
     */
    get err(): Error | undefined;
    /**
     * If defined, then the context supports cancel.  And it is possible to subscribe to it.
     *
     * @return Function that removes just signed listener from listeners.
     */
    onCancel?: (listener: OnCancelListener) => CtxUnsubcribe;
    /**
     * Creates a new context.
     */
    static createNew(opts?: IContextOpts): IContextCreateResult;
    /**
     * Creates a child context from the this one.
     *
     * Note: If there are no sufficient requirements for a new context the parent context
     * will be keep using.
     */
    createChild(opts?: IContextOpts): IContextCreateResult;
    /**
     * Makes a pr   omise cancellable through context, if the context allows cancel or has a timeout.
     */
    cancelRace<T>(promise: Promise<T>): Promise<T>;
    /**
     * Wraps a method with a context with specified properties. Just, syntactic sugar.
     */
    wrap<T>(opts: IContextOpts, fn: IContextWrapLambda<T>): Promise<T>;
    /**
     * True if the reason for canceling is timeout.
     */
    static isTimeout(cause: any): boolean;
    /**
     * True if the reason for canceling is call of ctx.Done() .
     */
    static isDone(cause: any): boolean;
    toString(): string;
    /**
     * Passes the context through a global variable, as in _npm context_.
     *
     * Allows context to be passed through code that does not know about the context and cannot be changed.  For example,
     * the code generated by protobufs js.
     *
     * It is important to pick up the context from the same synchronous code block that was called from ctx.do().  Otherwise, the context
     * will be removed or possibly a context from another branch of the logic will be set. Which would create confusion.
     *
     * In practice, if Context.get() is called in an async method.  It should be called before the first await - the easiest way is
     * to get the context in the first line of the function.
     *
     * @param fn a function of the form "() => AFuncOrMethod(...args)", at the moment of calling which the current context will be set.
     */
    do<T>(fn: () => T): T;
    /**
     * Returns the current context from global variable. See the description of Context.do() for a detailed explanation.
     */
    static get(): Context;
}
export {};
//# sourceMappingURL=context.d.ts.map